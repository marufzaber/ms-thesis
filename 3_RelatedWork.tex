\chapter{Related Work}
\label{sec:related}

A plethora of research on incremental testing of software repository can be found in the literature~\cite{leung1989insights,b34,b35, rothermel2000regression}. The core concept of regression testing can be generalized across languages ~\cite{harrold2001regression,b34}. 
Nonetheless, implementation of RTS tool largely varies across platforms i.e. build tools, environments, or even requirements. 
Despite this research literature spanning decades, RTS techniques are not used in mainstream software-development practice. Also, a bulk of RTS tools are not safe ~\cite{b35}. Even for intuitively safe RTS tools, proving safety is difficult. However, RTS tools still hold promises. This is evident from, Ekstazi, which has been adopted in several open-source projects. 
In this section, we describe previous work on RTS, including the use of change impact analysis in the context of RTS, the granularity at which RTS operates, and the use of static and dynamic information for RTS.

\section{Change Impact Analysis}
Change impact analysis (CIA)~\cite{b28} is critical for RTS, allowing techniques to determine which tests should be selected for re-execution. 
Li et al. propose a framework for change impact analysis with nine overarching characteristics, namely, object i.e. input-output, impact set, type of analysis i.e. static or dynamic, intermediate representation, language support, tool support, and empirical evaluation. 
Acharya et al. \cite{acharya2011practical} found that static slicing-based CIA does not scale for larger projects. \textit{PathImpact} uses dynamic slicing to perform CIA~\cite{law2003whole}. However, the technique was reported to be unsafe as it depends on the operational behavior of the software. Gethers et al.~\cite{b32} found that a combination of information retrieval, data mining, and source code analysis yields better precision and recall for CIA. Ren et al.~\cite{ren2004chianti} introduced \textit{Chianti}, a fine-grained change impact tool for Java. Chianti can isolate all semantically meaningful atomic changes that can potentially impact a test.  Buckner et al. proposed \textit{JRipples}, an eclipse plugin that assists developers with debugging and relies on CIA at the class level~\cite{buckner2005jripples}. Goknil et al.~\cite{b31} propose a technique for CIA at the architecture-and-design level.

Static CIA can be imprecise for object-oriented languages due to dynamic binding. However, static code analysis can be more efficient than dynamic analysis. Bacon proposed a fast algorithm for virtual method call resolution in C++~\cite{bacon1996fast}. Dean et al. used proposed a fast static analysis algorithm for class hierarchy in OOP~\cite{dean1995optimization}. These techniques can be leveraged to optimize software where throughput is an important performance metric~\cite{chambers1996whole}, such as operating systems and compilers.

\section{Granularity of Regression Test Selection}
The granularity of RTS has been studied extensively where different studies have found contradictory results. Bible et al. conducted a comparative study among RTS at varying granularity~\cite{biblecompare}. They compared TestTube \cite{b40}, a coarse-grained RTS tool with DejaVu, a fine-grained RTS tool, in terms of precision and analysis times required by the techniques. They argue that a hybrid approach is more promising, which contradicts Legunsen et al.'s recommendation of a coarse-grained approach~\cite{b37}. In their evaluation, method-based RTS selects more tests, making it less precise than class-based RTS~\cite{b37}. RTS at a coarser granularity, although less precise, has been shown to be effective nonetheless through the RTS technique Ekstazi~\cite{ekstazi}~\cite{ekstazi}. 

Method-based RTS tends to be more precise while incurring a greater cost (e.g., computational cost) for analyzing code. For example, Gligoric et al. propose RTS++, a call-graph-based RTS tool for C++ which runs at the function level. This tool was evaluated to be on average 38\% faster than re-test all. Method-level RTS selects fewer tests compared to coarser-grained RTS tools~\cite{faulttracer, hyrts, rtsplusplus}. However, reducing the test execution time might not necessarily yield shorter end-to-end testing times because the overhead of CIA for method-level RTS can be substantial. For example, in certain cases, \textit{FaultTracer} can be more expensive than retest-all~\cite{faulttracer}. Whether the cost stems from implementation issues or only from the computational load is not apparent~\cite{faulttracer}. 

Our evaluation of TLDR demonstrates that by incorporating parallelism  across the RTS pipeline, careful selection of checksum algorithms, and efficient database design, method-level RTS can outperform coarser-grained RTS.

\section{Dependency Collection in RTS}
Ekstazi selects tests at the class level based on dynamic dependencies at the file level~\cite{ekstazi}.
However, dynamic RTS is not always faster than static RTS~\cite{faulttracer}. To optimize the efficiency of dynamic test selection, RTS techniques are often designed to run in different phases. Orso et al. first proposed an RTS technique that involves two phases: a partition phase and selection phase~\cite{b43}. Ekstazi runs in three phases: analysis, execution, and collection phases~\cite{ekstazi}. 

Static RTS has been studied for decades but has achieved little industry adoption. STARTS is a static RTS technique that selects tests at the class level~\cite{starts}. Legunsen et al.~\cite{b37} conducted a comprehensive study of static RTS tools at different granularities and found that the safety issue of static RTS mainly arises from dynamic dispatch. They evaluated Ekstazi and STARTS~\cite{starts} with a method-level RTS technique~\cite{legunsen2016extensive}
and found that the  method level is an order of magnitude more expensive than class-level static and dynamic RTS. Contrary to their results, we have observed that TLDR, a method-level technique, takes less time for end-to-end testing than coarser-grained RTS tools. We believe this performance gain stems from the application of parallelism, the selection of an efficient checksum algorithm, and our efficient database schema design.

Hybrid approaches have also been proposed by researchers. Chen et al. \cite{b40} proposed TestTube, an RTS tool for C that utilizes both static and dynamic analysis of source. Static analysis is performed to detect source code change while dynamic analysis is conducted for dependency resolution~\cite{b40}. Panigrahi et al. proposed a hybrid RTS for object-oriented language~\cite{panigrahi}. This tool extracts control and data dependency from dynamic dependency graph and extracts program change by analyzing UML state machine models of the changed code.

Overall, TLDR and its evaluation demonstrate that using static information without dynamic information can result in an RTS technique that is precise.  safe with respect to all changes in source files of projects that do not involve reflection, and highly efficient in terms of end-to-end testing time. 
However, further improving RTS through a hybrid static-and-dynamic RTS technique is an interesting avenue for future work.

\raggedbottom
