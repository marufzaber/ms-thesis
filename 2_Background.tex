\chapter{Background}
\label{sec:background}

The idea of selecting a smaller set of regression tests based on what parts of the code changed is relatively old~\cite{leung1989insights}. Since its introduction, numerous techniques and tools have been proposed. We focus on recent techniques that target Java programs in this thesis. In this chapter, we lay the theoretical background of regression test selection along with examples, discuss several contemporary RTS tools, and introduce our proposed RTS tool, TLDR. 

\section{Regression Test Selection}

Regression test selection (RTS) is a technique of selecting and executing a subset of tests instead of the complete test suite in a way that is still safe i.e achieves the same test result in each iteration~\cite{engstrom2010systematic, gligoric2014regression, gligoric2015regression}. A high-level overview of RTS is shown in figure \ref{fig:rtsoverview}. There are two main steps of RTS, namely, \textit{analysis phase} and \textit{execution phase}. In the analysis phase, the tests that are affected by the current change are identified. This step requires storing information about the latest iteration i.e. commit of the repository, for example, state of each source-code files and external files, dependency graph, and test-to-source map. In each iteration, the repository is parsed statically and compared with the stored state to analyze the change in the current iteration. Once the changes are identified, the stored dependency graph is updated. In some RTS tools this stage is considered as a separate phase of analysis i.e. \textit{Collection Phase}~\cite{gligoric2015regression}. Then from the nodes that correspond to the changed entities i.e. packages or classes or methods, the dependency graph is traversed to find out all the entities that are impacted by the changes in the current iteration. This set of entities is called \textit{firewell}. In the second step of RTS, each test function that covers the entities that belong to the firewell is selected and run.   

\begin{figure*}
\begin{center}
  \includegraphics[width=16cm,height=5.5cm]{regression}
  \caption{High-level overview of Regression Test Selection}
  \label{fig:rtsoverview}
\end{center}
\end{figure*}

The analysis required for RTS can be expensive. However, the efficiency of RTS stems from the minimization of the test suite. It selects and runs significantly fewer number of tests compared to the entire test-suite, therefore, incurs less end-to-end testing time. RTS can result in larger end-to-end time for smaller test suites or iterations where a substantial among of code refactoring has been done. However, RTS guarantees that the average end-to-end time for a series of iterations is always less than the \textit{retest-all}. Oftentimes, RTS is combined with test prioritization for better efficiency. For example, instead of the complete project, RTS can be run only on the parts of the project that are visible to the user, bug- or error-prone, critical to the business requirement, or complex. Other optimization approach involves parallelly running the selected tests~\cite{candido2017test}. However, no prior work has explored the scope of parallelization in the test selection process. In this thesis, we explore the application of parallelization in test selection as well as test run to achieve better optimization. 

\section{Types of RTS}

RTS tools vary along three overarching dimensions: (i) the granularity of test selection, (ii) the granularity of change impact analysis, and (iii) how dependencies are collected.

\subsection{Granularity of Test Selection}

In Java programs, test suites are encapsulated in a set of test classes, each one containing one or more test methods. These test classes are placed within test packages. RTS tools can select tests by package i.e. all test methods within the selected package, by classes i.e. all test methods within the selected test classes, by methods i.e. precisely selected test methods. The test methods in a test class often rely on common setup and tear-down code, but good practices dictate that each test method be independent of the others, which does not always happen. Therefore, the first decision an RTS technique for Java programs must make is the granularity of test selection. Because test methods are supposed to be independent of each other, in theory, method-level test selection allows us to identify exactly the least amount of tests to be selected for a given change. However, it has been observed that sometimes projects do not follow the principle of test method independence~\cite{b18}. Therefore, the extra complexity and runtime overhead associated with selecting individual methods instead of classes may not be justified in practice. This is a design decision that benefits from collecting empirical data about how Java developers write test suites. Nevertheless, if the overhead of selecting test methods is low, and assuming that at least some test suites follow test method independence, it will always be desirable to select individual tests.

\subsection{Granularity of Change Impact Analysis}

Another dimension of variance is the granularity of change impact analysis. Source code can be analyzed at four different levels of granularity: file-level, class-level, member-level (i.e. methods and fields), and statement-level. On the one hand, the smaller the granularity of analysis, the more precise RTS can be. For example, if only the name of a local variable changed, statement-level change impact analysis should be able to infer that no regression testing would be necessary for that change because it had no impact; member-level analysis would identify that particular method as the only entity that needs retesting; class-level analysis would select that entire class as the entity to be retested; and finally, file-level analysis would select that file, possibly with many classes, as the entity to be retested. On the other hand, the smaller the granularity of analysis, the more complex RTS becomes, and that often comes with additional runtime overhead that may not compensate for the increased precision of test selection. Particularly, for larger projects, small granularity can be impractical because building precise dependency graph will be prohibitively expensive. Contrarily, coarser granularity is less precise. For example, a class-level RTS tool would select all the test methods within an impacted test class even if only one out of many test methods was impacted by the latest change. The inefficiency induced by the imprecision is compensated by the efficient test selection process as it is significantly less expensive to build and traverse class-level or file-level dependency graph. However, if the change in the source-code is distributed across many files coarser-granularity RTS tool can be impractical because it will select a significantly large number of unwanted test methods. 

\subsection{Dependency Collection}

Change impact analysis requires the construction of a dependency graph among entities -- files, classes, methods, and even statements -- of the subject project. The third dimension along which RTS techniques differ is in how they build the dependency graphs. There are two main ways of gathering dependencies: static analysis~\cite{rtsplusplus, starts}, and dynamic analysis~\cite{ekstazi, faulttracer}; a third approach is to use both~\cite{hyrts}. Dynamic analysis of dependencies is particularly desirable for object-oriented languages because of their dynamic binding features~\cite{rountev2004static}. Dynamic dependency graph generation is prohibitively expensive for finer granularity, such as member-level, making such RTS techniques impractical~\cite{fairley1978tutorial}. However, dynamic RTS is safe as it captures the actual firewell. Static RTS tools, contrarily, captures dependency by static analysis of the source offline. Safety is maintained by traversing the entire class-hierarchy of the impacted members. However, if the repository makes use of reflection, instrumentation, or if any external resources, for example, external files, database are used static RTS can be unsafe. 

\section{Regression Test Selection Techniques and Tools}

 In this section, we describe four contemporary RTS tools for Java projects, namely, FaultTracer~\cite{faulttracer}, Ekstazi~\cite{ekstazi}, STARTS~\cite{starts}, and HyRTS~\cite{hyrts}. Among these four tools, FaultTracer and HyRTS are not open-source. We collected HyRTS from the author of the tool. However, we could not collect FaultTracer's artifact. Hence, STARTS, Ektazi, and HyRTS are used as baselines to evaluate the proposed RTS tool, TLDR. 

\subsection{FaultTracer}
FaultTracer is one of the earliest RTS tools written in Java~\cite{faulttracer}. FaultTracer is a dynamic RTS tool that analyzes changes in statement-level and selects tests at method-level. Given two versions of a program, in order to find all atomic changes in the program,  it builds an enhanced call graph called \textit{Extended Call Graph (ECG)} that augments the traditional method call graph with field access information. ECG is built by statement-level analysis of the source-code. Furthermore, in order to reduce manual inspection, FaultTracer combines change-analysis-based test selection with a fault localization component. For each failed test in the current iteration, it ranks the atomic changes based on their suspiciousness. To calculate the suspicious score of a particular edit, it adapts four spectrum-based fault location techniques. These techniques are based on the following heuristics (i) statements that are only covered by failed tests are more suspicious, (ii) statements that are executed by more number of failed tests than passed tests are statistically more suspicious, (iii) statements whose Jaccard Similarity Coefficient~\cite{abreu2007accuracy} i.e. ratio between the number of associated failed tests and the summation of the number of all failed tests and number of associated passed tests, are higher, are more suspicious, and (iv) statement whose Ochiai coefficient~\cite{abreu2007accuracy, yu2008empirical} is higher, is more suspicious. 

\subsection{Ekstazi}
Ekstazi is the most popular open-source RTS tool for Java. This is a Maven plugin that runs RTS for Java unit tests~\cite{ekstazi, gligoric2015ekstazi}. Ekstazi is a dynamic RTS tool that analyzes changes by file-level granularity and selects tests by class-level granularity. Since Ekstazi has coarser granularity, it selects higher number of tests. However, due to its efficient test selection technique, it incurs less end-to-end testing time. Ekstazi runs into three phases, namely, \textit{analysis phase}, \textit{execution phase}, and \textit{collection phase}. In the analysis phase, Ekstazi calculates the checksum of each file in the repository and compares with previously-stored checksum to find out the changed files. After that, it selects the tests that cover these files. In the execution phase, it dynamically updates the list of tests to be run by the Maven test executor i.e. \textit{Surefire} to run only the selected tests. In the collection phase, Ekstazi instruments the stack-trace of the selected tests to collect dynamic dependencies. Since Ekstazi collects file-level dependencies dynamically, it is safe even if the repository uses external resources. The artifact publicly available in this URL - \href{url}{https://github.com/gliga/ekstazi}. 

\subsection{STARTS}

STARTS is a class-level static RTS tool~\cite{starts}. Like Ekstazi, this is also a Maven plugin for Java unit tests. STARTS efficiency stems from efficient compile-time code analysis as it does not involve instrumentation or reflection which are computationally expensive. Like Ekstazi, STARTS also stores and compares the checksum of each class for change analysis. STARTS computes the firewall of each changed class by traversing the transitive closure in the static dependency graph. In object-oriented programming language like Java, dependencies are resolved in run-time. Therefore, in order to uphold safety, STARTS adds redundant edges to all the classes in the class hierarchy. Therefore, the firewall of each changed class includes all the classes that are impacted or may have been impacted by the recent change. The inefficiency, induced by the selection of higher number of tests is compensated by the efficient test selection. STARTS is publicly available in this URL - \href{url}{https://github.com/marufzaber/STARTS-Fork}.

\subsection{HyRTS}
HyRTS is a class-level dynamic RTS tool~\cite{hyrts}. However, unlike Ekstazi and STARTS, HyRTS implements a hybrid-granularity change impact analysis, therefore, combines the strength of both class-level and method-level RTS techniques. HyRTS performs method-level analysis for method-level changes like addition, deletion, and edition of statements, addition, and deletion of methods, etc., and class-level analysis for class-level changes like addition and deletion of files, class header change. HyRTS performs these two different granular analyses in two separate phases and finally, combines the selected tests. Like Ekstazi, HyRTS has a separate collection phase that collects dependencies by instrumenting the stacktrace of the selected tests. However, a hybrid RTS tool that collects dependencies offline has been documented to be more efficient than the one that collects dependencies online due to the overhead of instrumentation. HyRTS is publicly available in this URL - \href{url}{https://github.com/marufzaber/HyRTS-Fork}.
